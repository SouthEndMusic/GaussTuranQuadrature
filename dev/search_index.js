var documenterSearchIndex = {"docs":
[{"location":"theory/#Gauss-Turán-quadrature-rules","page":"Theory","title":"Gauss-Turán quadrature rules","text":"","category":"section"},{"location":"theory/#Definition","page":"Theory","title":"Definition","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"A Gauss-Turán quadrature rule is an operation on a function f  (ab) rightarrow mathbbR of the form","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    I(f) = sum_m=1^2s + 1 sum_i = 1^n w_mif^(m-1)(x_i)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"defined by the weights w_mi in mathbbR and the n nodes x_i in (a b), where for the rest of this section we will assume that a = 0 and b = 1. These variables are chosen such that for a set of linearly independent functions","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    varphi_1 ldots varphi_2(s+1)n in C^2s+1(01)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(i.e. (2s+1) times continuously differentiable on (01)) the operator I gives an exact value for the integral:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    I(varphi_j) = int_0^1varphi_j(x)textdx quad j=1ldots2(s+1)n\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"By linearity, I will also given exact integrals for linear combinations of the functions varphi_j. For functions f that are well approximated by linear combinations of the varphi_j, I will give a good approximation of the integral:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    I(f) approx int_0^1f(x)textdx\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The value s in mathbbN determines the highest order derivative (2s) that is required to evaluate the quadrature rule. Gaussian quadrature uses s = 0 and orthogonal polynomials varphi_j.","category":"page"},{"location":"theory/#Generalizing-to-any-interval-(a,b)","page":"Theory","title":"Generalizing to any interval (ab)","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Say we have a quadrature rule as defined in the previous section, but now we want to use it to integrate a function over the interval (ab). By integral transformation rules we have that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign\n    int_a^b f(t)textdt = (b - a) int_0^1 f(a + (b-a)x)textdx \n    approx (b-a)I(tildef)\nendalign","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where tildef(x) = f(a + (b-a)x). We can interpret f mapsto (b-a)I(tildef) as a quadrature rule with","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"weights multiplied by b-a;\ntransformed nodes a + (b-a)x_i;\nderivatives in the \"direction\" b - a.","category":"page"},{"location":"theory/#Deriving-Gauss-Turán-quadrature-rules","page":"Theory","title":"Deriving Gauss-Turán quadrature rules","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The algorithm presented here is not published anywhere as far as the author is aware. For an example of an older algorithm that uses an analytically derived Jacobian see here.","category":"page"},{"location":"theory/#Deriving-a-loss-function","page":"Theory","title":"Deriving a loss function","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"For given functions varphi_j, (3) defines 2(n+1)n equations in the weights and nodes of the quadrature rule. These give (2s + 1)n + n = 2(s + 1)n degrees of freedom, and thus we have a system of equations which in principle we can solve. Due to the varphi_j this is a nonlinear problem, and so we derive a numerical method which will converge to the quadrature rule.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We reformulate (3) as a linear system","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    M(mathbfx)mathbfw = mathbfb\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the matrix M(mathbfx) is of size 2(s+1)n times (2s + 1)n (note that it is not square!) and consisting of the evaluations of the derivatives of the varphi_j:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nM(mathbfx)_jk(m i) = varphi_j^(m-1)(x_i)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"the column vector mathbfw = (w_k(m i)) is of length (2s+1)n;\nthe column vector mathbfb is of length 2(s+1)n and consisting of the integrals of the varphi_j:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    b_j = int_a^b varphi_j(x)textdx\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"here k(mi) is an unrolling of the double sum in (1) into a single dimension.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For given nodes mathbfx we can solve the first (2s+1)n equations of this linear system for the weights mathbfx. To this end we split the matrix M(mathbfx) into an upper part M_textupper(mathbfx) of (square) size (2s+1)n times (2s+1)n and a lower part of M_textlower of size n times (2s + 1)n. The right hand side vector mathbfb is split analogously into mathbfb_textupper and mathbfb_textlower. This gives","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    mathbfw = M_textupper(mathbfx)^-1mathbfb_textupper\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where in the implementation this will be solved as a linear system instead of computing the inverse M_textupper(mathbfx)^-1 explicitly.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Given these weights, we can check the validity of the last n equations, which yields the loss function","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    textloss(mathbfx) = M_textlower(mathbfx) - mathbfb_textlower_2 \n    = \n    M_textlower(mathbfx)M_textupper(mathbfx)^-1mathbfb_textupper - mathbfb_textlower _2\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fully expressed in terms of the nodes mathbfx.","category":"page"},{"location":"theory/#Constraining-the-optimization-problem","page":"Theory","title":"Constraining the optimization problem","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We want to solve for the quadrature rule by approximating the root of the above loss function with a Newton solver. However, a naive implementation of this can lead to numerical problems, because the different nodes can converge towards eachother which makes the matrix M_textlower(mathbfx) singular. Furthermore, we want the nodes to stay within the interval (01).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To this end we define the new variables","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    Delta mathbfx = (Delta x_1 Delta x_2 ldots Delta x_n) = (x_1 x_2 - x_1 ldots x_n - x_n-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which implies","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    x_i = sum_i = 1^i Delta x_i\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and a new loss function textLoss(Deltamathbfx) in terms of these variables. Given a minimal distance between the nodes 0 varepsilon le frac1n+1, we define the constraints","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    varepsilon le Delta x_i le 1-2varepsilon quad i = 1 ldots n\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and the final constraint","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\n    nvarepsilonle sum_i=1^n Delta x_i le 1-varepsilon\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nSince we solve this problem with Optim.IPNewton which requires a hessian of the loss function, we actually need the functions varphi_j to be 2s + 2 times continuously differentiable.","category":"page"},{"location":"evaluate_rule/#Evaluating-Gauss-Turán-quadrature-rules","page":"Evaluating quadratures","title":"Evaluating Gauss-Turán quadrature rules","text":"","category":"section"},{"location":"evaluate_rule/","page":"Evaluating quadratures","title":"Evaluating quadratures","text":"GaussTuranQuadrature contains precomputed quadrature rules, which can be used as follows.","category":"page"},{"location":"evaluate_rule/","page":"Evaluating quadratures","title":"Evaluating quadratures","text":"using GaussTuranQuadrature\n\nn = 3\ns = 2\n\nI = GaussTuranRule(n, s)","category":"page"},{"location":"evaluate_rule/","page":"Evaluating quadratures","title":"Evaluating quadratures","text":"# Define a function with cheap computation of the derivatives\nfunction f(x)\n    val = sin(x)\n    der = sqrt(1 - val^2) # cos\n    (val, der, -val, -der, val)\nend\n\nevaluation = I(f)\nerror = abs(evaluation - (1 - cos(1)))","category":"page"},{"location":"evaluate_rule/","page":"Evaluating quadratures","title":"Evaluating quadratures","text":"Other finite domains (ab) can also be used.","category":"page"},{"location":"evaluate_rule/","page":"Evaluating quadratures","title":"Evaluating quadratures","text":"I = GaussTuranRule(n, s; domain = (0, π/2))\nI(f)","category":"page"},{"location":"compute_rule/#Computing-Gauss-Turán-qudrature-rules","page":"Computing quadratures","title":"Computing Gauss-Turán qudrature rules","text":"","category":"section"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"In this section we look at how to use the algorithm in GaussTuranQuadrature.jl to compute new quadrature rules. For the mathematical background of this algorithm see the theory section. We use the example presented in this article, with the functions","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"beginequation\n    varphi_j(x) = x^p_j quad j = 1 ldots 2(s + 1)n\nendequation","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"where","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"beginequation\n    p_j =\n    begincases\n        fracj2 - 1 text if j is even \n        fracj - 12 - frac13 text if j is odd\n    endcases\nendequation","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"and the trivial weight function w(x) = 1.","category":"page"},{"location":"compute_rule/#Computing-the-rule","page":"Computing quadratures","title":"Computing the rule","text":"","category":"section"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"Below is some setup of the inputs for computing the rule.","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"using TaylorDiff: derivatives\n\np(n, s) = [j % 2 == 0 ? j / 2 - 1 : (j - 1) / 2 - 1 / 3 for j in 1:(2 * (s + 1) * n)]\n\nn = 5\ns = 1\n\n# Powers of the input functions\nP = p(n, s)\n\n# Integrals over (0, 1) of the input functions\nrhs = @. 1 / (P + 1)\n\n# The functions themselves and their derivatives\nϕ = (x, j) -> derivatives(x -> x^P[j], x, 1.0, Val(2s + 1)).value;","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"Now we can compute the rule.","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"using Optim\nusing TaylorDiff\nusing PreallocationTools\nusing GaussTuranQuadrature\n\nI, res = GaussTuranComputeRule(ϕ, n, s, rhs)\n\nI","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"And evaluate the rule.","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"# Create a function which computes exp(x) once and fills a tuple of length 2s+1 with that value\nf = x -> (val = Base.exp(x); ntuple(_ -> val, 2s + 1))\n\nevaluation = I(f)\nerror = abs(evaluation - (Base.exp(1) - 1))\nerror","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"We can also have a look at the optimization statistics.","category":"page"},{"location":"compute_rule/","page":"Computing quadratures","title":"Computing quadratures","text":"res","category":"page"},{"location":"compute_rule/#Obtaining-higher-accuracy","page":"Computing quadratures","title":"Obtaining higher accuracy","text":"","category":"section"},{"location":"#GaussTuranQuadrature","page":"Home","title":"GaussTuranQuadrature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tabulation and computation in Julia of 1D Gauss-Turán quadrature rules, a generalization of Gaussian quadrature which also uses derivative evaluations of the integrand.","category":"page"}]
}
